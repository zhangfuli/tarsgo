//Package MicroserviceDemo comment
// This file war generated by tars2go 1.1
// Generated from DoUser.tars
package MicroserviceDemo

import (
	"context"
	"fmt"
	"github.com/TarsCloud/TarsGo/tars"
	m "github.com/TarsCloud/TarsGo/tars/model"
	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
	"github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	"github.com/TarsCloud/TarsGo/tars/util/current"
	"github.com/TarsCloud/TarsGo/tars/util/tools"
)

//DoUser struct
type DoUser struct {
	s m.Servant
}

//EchoHello is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) EchoHello(Name string, Greeting *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Name, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "echoHello", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Greeting), 2, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//EchoHelloWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) EchoHelloWithContext(ctx context.Context, Name string, Greeting *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Name, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "echoHello", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Greeting), 2, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Login is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) Login(Username string, Password string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Username, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Password, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "login", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//LoginWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) LoginWithContext(ctx context.Context, Username string, Password string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Username, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Password, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "login", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Register is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) Register(Username string, Password string, Email string, First string, Last string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Username, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Password, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Email, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(First, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Last, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "register", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegisterWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) RegisterWithContext(ctx context.Context, Username string, Password string, Email string, First string, Last string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Username, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Password, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Email, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(First, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Last, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "register", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Customers is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) Customers(_opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "customers", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CustomersWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) CustomersWithContext(ctx context.Context, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "customers", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteCustomerById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) DeleteCustomerById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "deleteCustomerById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteCustomerByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) DeleteCustomerByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "deleteCustomerById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCustomerById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCustomerById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "findCustomerById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCustomerByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCustomerByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "findCustomerById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCustomerCardById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCustomerCardById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "findCustomerCardById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCustomerCardByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCustomerCardByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "findCustomerCardById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCustomerAddressById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCustomerAddressById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "findCustomerAddressById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCustomerAddressByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCustomerAddressByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "findCustomerAddressById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Cards is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) Cards(_opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "cards", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CardsWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) CardsWithContext(ctx context.Context, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "cards", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddCard is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) AddCard(LongNum string, Expires string, Ccv string, UserID string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(LongNum, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Expires, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Ccv, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(UserID, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "addCard", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddCardWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) AddCardWithContext(ctx context.Context, LongNum string, Expires string, Ccv string, UserID string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(LongNum, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Expires, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Ccv, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(UserID, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "addCard", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteCardById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) DeleteCardById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "deleteCardById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteCardByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) DeleteCardByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "deleteCardById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCardById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCardById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "findCardById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindCardByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindCardByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "findCardById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Addresses is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) Addresses(_opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "addresses", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddressesWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) AddressesWithContext(ctx context.Context, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "addresses", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddAddress is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) AddAddress(Street string, Number string, Country string, City string, Postcode string, UserID string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Street, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Number, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Country, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(City, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Postcode, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(UserID, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "addAddress", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddAddressWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) AddAddressWithContext(ctx context.Context, Street string, Number string, Country string, City string, Postcode string, UserID string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Street, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Number, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Country, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(City, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Postcode, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(UserID, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "addAddress", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteAddressById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) DeleteAddressById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "deleteAddressById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteAddressByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) DeleteAddressByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "deleteAddressById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindAddressById is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindAddressById(Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	ctx := context.Background()
	err = _obj.s.Tars_invoke(ctx, 0, "findAddressById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//FindAddressByIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DoUser) FindAddressByIdWithContext(ctx context.Context, Id string, _opt ...map[string]string) (ret string, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(Id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Tars_invoke(ctx, 0, "findAddressById", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_string(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_obj.setMap(len(_opt), _resp, _context, _status)
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetServant sets servant for the service.
func (_obj *DoUser) SetServant(s m.Servant) {
	_obj.s = s
}

//TarsSetTimeout sets the timeout for the servant which is in ms.
func (_obj *DoUser) TarsSetTimeout(t int) {
	_obj.s.TarsSetTimeout(t)
}
func (_obj *DoUser) setMap(l int, res *requestf.ResponsePacket, ctx map[string]string, sts map[string]string) {
	if l == 1 {
		for k, _ := range ctx {
			delete(ctx, k)
		}
		for k, v := range res.Context {
			ctx[k] = v
		}
	} else if l == 2 {
		for k, _ := range ctx {
			delete(ctx, k)
		}
		for k, v := range res.Context {
			ctx[k] = v
		}
		for k, _ := range sts {
			delete(sts, k)
		}
		for k, v := range res.Status {
			sts[k] = v
		}
	}
}

//AddServant adds servant  for the service.
func (_obj *DoUser) AddServant(imp _impDoUser, obj string) {
	tars.AddServant(_obj, imp, obj)
}

//AddServant adds servant  for the service with context.
func (_obj *DoUser) AddServantWithContext(imp _impDoUserWithContext, obj string) {
	tars.AddServantWithContext(_obj, imp, obj)
}

type _impDoUser interface {
	EchoHello(Name string, Greeting *string) (ret int32, err error)
	Login(Username string, Password string) (ret string, err error)
	Register(Username string, Password string, Email string, First string, Last string) (ret string, err error)
	Customers() (ret string, err error)
	DeleteCustomerById(Id string) (ret string, err error)
	FindCustomerById(Id string) (ret string, err error)
	FindCustomerCardById(Id string) (ret string, err error)
	FindCustomerAddressById(Id string) (ret string, err error)
	Cards() (ret string, err error)
	AddCard(LongNum string, Expires string, Ccv string, UserID string) (ret string, err error)
	DeleteCardById(Id string) (ret string, err error)
	FindCardById(Id string) (ret string, err error)
	Addresses() (ret string, err error)
	AddAddress(Street string, Number string, Country string, City string, Postcode string, UserID string) (ret string, err error)
	DeleteAddressById(Id string) (ret string, err error)
	FindAddressById(Id string) (ret string, err error)
}
type _impDoUserWithContext interface {
	EchoHello(ctx context.Context, Name string, Greeting *string) (ret int32, err error)
	Login(ctx context.Context, Username string, Password string) (ret string, err error)
	Register(ctx context.Context, Username string, Password string, Email string, First string, Last string) (ret string, err error)
	Customers(ctx context.Context) (ret string, err error)
	DeleteCustomerById(ctx context.Context, Id string) (ret string, err error)
	FindCustomerById(ctx context.Context, Id string) (ret string, err error)
	FindCustomerCardById(ctx context.Context, Id string) (ret string, err error)
	FindCustomerAddressById(ctx context.Context, Id string) (ret string, err error)
	Cards(ctx context.Context) (ret string, err error)
	AddCard(ctx context.Context, LongNum string, Expires string, Ccv string, UserID string) (ret string, err error)
	DeleteCardById(ctx context.Context, Id string) (ret string, err error)
	FindCardById(ctx context.Context, Id string) (ret string, err error)
	Addresses(ctx context.Context) (ret string, err error)
	AddAddress(ctx context.Context, Street string, Number string, Country string, City string, Postcode string, UserID string) (ret string, err error)
	DeleteAddressById(ctx context.Context, Id string) (ret string, err error)
	FindAddressById(ctx context.Context, Id string) (ret string, err error)
}

func echoHello(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Name string
	err = _is.Read_string(&Name, 1, true)
	if err != nil {
		return err
	}
	var Greeting string
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.EchoHello(Name, &Greeting)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.EchoHello(ctx, Name, &Greeting)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	}

	err = _os.Write_string(Greeting, 2)
	if err != nil {
		return err
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func login(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Username string
	err = _is.Read_string(&Username, 1, true)
	if err != nil {
		return err
	}
	var Password string
	err = _is.Read_string(&Password, 2, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.Login(Username, Password)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.Login(ctx, Username, Password)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func register(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Username string
	err = _is.Read_string(&Username, 1, true)
	if err != nil {
		return err
	}
	var Password string
	err = _is.Read_string(&Password, 2, true)
	if err != nil {
		return err
	}
	var Email string
	err = _is.Read_string(&Email, 3, true)
	if err != nil {
		return err
	}
	var First string
	err = _is.Read_string(&First, 4, true)
	if err != nil {
		return err
	}
	var Last string
	err = _is.Read_string(&Last, 5, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.Register(Username, Password, Email, First, Last)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.Register(ctx, Username, Password, Email, First, Last)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func customers(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.Customers()
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.Customers(ctx)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func deleteCustomerById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.DeleteCustomerById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.DeleteCustomerById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func findCustomerById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.FindCustomerById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.FindCustomerById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func findCustomerCardById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.FindCustomerCardById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.FindCustomerCardById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func findCustomerAddressById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.FindCustomerAddressById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.FindCustomerAddressById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func cards(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.Cards()
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.Cards(ctx)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func addCard(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var LongNum string
	err = _is.Read_string(&LongNum, 1, true)
	if err != nil {
		return err
	}
	var Expires string
	err = _is.Read_string(&Expires, 2, true)
	if err != nil {
		return err
	}
	var Ccv string
	err = _is.Read_string(&Ccv, 3, true)
	if err != nil {
		return err
	}
	var UserID string
	err = _is.Read_string(&UserID, 4, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.AddCard(LongNum, Expires, Ccv, UserID)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.AddCard(ctx, LongNum, Expires, Ccv, UserID)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func deleteCardById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.DeleteCardById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.DeleteCardById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func findCardById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.FindCardById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.FindCardById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func addresses(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.Addresses()
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.Addresses(ctx)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func addAddress(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Street string
	err = _is.Read_string(&Street, 1, true)
	if err != nil {
		return err
	}
	var Number string
	err = _is.Read_string(&Number, 2, true)
	if err != nil {
		return err
	}
	var Country string
	err = _is.Read_string(&Country, 3, true)
	if err != nil {
		return err
	}
	var City string
	err = _is.Read_string(&City, 4, true)
	if err != nil {
		return err
	}
	var Postcode string
	err = _is.Read_string(&Postcode, 5, true)
	if err != nil {
		return err
	}
	var UserID string
	err = _is.Read_string(&UserID, 6, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.AddAddress(Street, Number, Country, City, Postcode, UserID)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.AddAddress(ctx, Street, Number, Country, City, Postcode, UserID)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func deleteAddressById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.DeleteAddressById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.DeleteAddressById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}
func findAddressById(ctx context.Context, _val interface{}, _os *codec.Buffer, _is *codec.Reader, withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	var Id string
	err = _is.Read_string(&Id, 1, true)
	if err != nil {
		return err
	}
	if withContext == false {
		_imp := _val.(_impDoUser)
		ret, err := _imp.FindAddressById(Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	} else {
		_imp := _val.(_impDoUserWithContext)
		ret, err := _imp.FindAddressById(ctx, Id)
		if err != nil {
			return err
		}

		err = _os.Write_string(ret, 0)
		if err != nil {
			return err
		}
	}

	_ = length
	_ = have
	_ = ty
	return nil
}

//Dispatch is used to call the server side implemnet for the method defined in the tars file. withContext shows using context or not.
func (_obj *DoUser) Dispatch(ctx context.Context, _val interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) {
	_is := codec.NewReader(tools.Int8ToByte(req.SBuffer))
	_os := codec.NewBuffer()
	switch req.SFuncName {
	case "echoHello":
		err := echoHello(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "login":
		err := login(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "register":
		err := register(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "customers":
		err := customers(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "deleteCustomerById":
		err := deleteCustomerById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "findCustomerById":
		err := findCustomerById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "findCustomerCardById":
		err := findCustomerCardById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "findCustomerAddressById":
		err := findCustomerAddressById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "cards":
		err := cards(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "addCard":
		err := addCard(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "deleteCardById":
		err := deleteCardById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "findCardById":
		err := findCardById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "addresses":
		err := addresses(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "addAddress":
		err := addAddress(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "deleteAddressById":
		err := deleteAddressById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}
	case "findAddressById":
		err := findAddressById(ctx, _val, _os, _is, withContext)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var _status map[string]string
	s, ok := current.GetResponseStatus(ctx)
	if ok && s != nil {
		_status = s
	}
	var _context map[string]string
	c, ok := current.GetResponseContext(ctx)
	if ok && c != nil {
		_context = c
	}
	*resp = requestf.ResponsePacket{
		IVersion:     1,
		CPacketType:  0,
		IRequestId:   req.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(_os.ToBytes()),
		Status:       _status,
		SResultDesc:  "",
		Context:      _context,
	}
	return nil
}
